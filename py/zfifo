#!/usr/bin/env python
## -*- python -*-
# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

import sys
import argparse
import subprocess
from pprint import pprint
import json

debug = False

snap_fmt = {
    'uuid':
    {'title': 'UUID', 'len': 36, 'fmt': '%36s', 'get': lambda e: d(e, ['uuid'])},
    'timestamp':
    {'title': 'Timestamp', 'len': 20, 'fmt': '%-20s',
     'get': lambda e: datetime.fromtimestamp(d(e, ['timestamp'])/1000000).isoformat()},
    'size':
    {'title': 'Size', 'len': 5, 'fmt': '%5d', 'get': lambda e: d(e, ['size'])},
    'comment':
    {'title': 'Comment', 'len': 30, 'fmt': '%-30s', 'get': lambda e: d(e, ['comment'])},
}

backup_fmt = {
    'uuid':
    {'title': 'UUID', 'len': 36, 'fmt': '%36s', 'get': lambda e: d(e, ['uuid'])},
    'parent':
    {'title': 'Parent', 'len': 36, 'fmt': '%36s', 'get': lambda e: d(e, ['parent'])},
    'local':
    {'title': 'Local', 'len': 5, 'fmt': '%5s', 'get': lambda e: 'Yes' if d(e, ['local']) else 'No'},
    'size':
    {'title': 'Size', 'len': 15, 'fmt': '%5d', 'get': lambda e: d(e, ['size'], 0)},
    'state':
    {'title': 'State', 'len': 10, 'fmt': '%10s', 'get': lambda e: d(e, ['state'])},
    'timestamp':
    {'title': 'Timestamp', 'len': 20, 'fmt': '%-20s',
     'get': lambda e: datetime.fromtimestamp(d(e, ['timestamp'])/1000000).isoformat()},
    'comment':
    {'title': 'Comment', 'len': 30, 'fmt': '%-30s', 'get': lambda e: d(e, ['comment'])},
}

# We need to add a own action for lists as arguments
class ListAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values.split(','))

# Gets a value from a nested hash map or returns a given default if the value
# is not present
def d(o, p, deflt="-"):
    if p == []:
        return o
    else:
        k = p[0]
        if k in o:
            return d(o[k], p[1:], deflt)
        else:
            return deflt

# Helper function to generate a formatstring out of the format definition and the selected fields
def mk_fmt_str(args):
    s = ""
    for k in args.fmt:
        s = s + args.fmt_def[k]['fmt'] + " "
    return s

# Helper function to generate the format values for one of the lines.
def mk_fmt_line(args, e):
    r = []
    for k in args.fmt:
        r.append(args.fmt_def[k]['get'](e))
    return r

# Prints the header for a list opperation based on the selected format
def header(args):
    fmt = mk_fmt_str(args)
    hfmt = fmt.replace('d', 's')
    r = []
    for k in args.fmt:
        r.append(args.fmt_def[k]['title'])
    if args.p:
        print(":".join(r))
    else:
        print(hfmt % tuple(r))
    r = []
    if not args.p:
        for k in args.fmt:
            r.append("-" * args.fmt_def[k]['len'])
        print(hfmt % tuple(r))

def list_to_array(r, k):
    l = []
    for i in r:
        e = r[i]
        e[k] = i
        l.append(e)
    return l

def invoke(payload):
    j = json.dumps(payload)
    if debug:
        print '< ', j
    res = subprocess.check_output([UTIL, j])
    if debug:
        print '> ', res
    return json.loads(res)

# Shows the data when list was selected.
def show_list(args):
    r = invoke(args.payload)
    if args.json:
        print(json.dumps(r, sort_keys=True, indent=2, separators=(',', ': ')))
        exit(0)
    if type(r) == type(dict()):
        l = list_to_array(r, 'uuid')
    else:
        l = r
    if not l and l != []:
        print("error!")
        exit(1)
    if args.H:
        header(args)
    fmt = mk_fmt_str(args)
    for e in l:
        if not e:
            print("error!")
            exit(1)
        l = mk_fmt_line(args, e)
        if args.p:
            print(":".join(l))
        else:
            print(fmt%tuple(l))


def zfs_list(args):
    r = invoke({'action' :'zfs-list'})
    if r['reply']:
        print(r['reply'])
        exit(0)
    else:
        print(r['error'])
        exit(1)

def show_cluster_vms(args):
    r = invoke(args.payload)
    if args.json:
        print(json.dumps(r, sort_keys=True, indent=2, separators=(',', ': ')))
        exit(0)

    if not r and r != []:
        print("error!")
        exit(1)
    for e in r:
        print(e)

def show_stack_vms(args):
    r = invoke(args.payload)
    if args.json:
        print(json.dumps(r, sort_keys=True, indent=2, separators=(',', ': ')))
        exit(0)

    if not r and r != []:
        print("error!")
        exit(1)
    for e in r:
        print(e)

def snapshot_create(args):
    p = args.payload
    p['comment'] = args.comment
    res = invoke(args.payload)
    if args.json:
        print res
        exit(0)
    if res:
        print 'Snapshot successfully created!'
    else:
        print 'Snapshot creation failed!'

def backup_create(args):
    p = args.payload
    p['comment'] = args.comment
    p['delete'] = args.parent or False

    if args.parent:
        p['parent'] = args.parent

    res = invoke(args.payload)
    if args.json:
        print res
        exit(0)
    if res:
        print 'Snapshot successfully created!'
    else:
        print 'Snapshot creation failed!'

def json_get(args):
    res = invoke(args.payload)
    print(json.dumps(res, sort_keys=True, indent=2, separators=(',', ': ')))

def json_set(args):
    value = args.value
    if args.integer:
        value = int(args.value)
    elif args.float:
        value = float(args.value)
    elif args.json:
        value = json.loads(args.value)
    payload = args.payload
    payload['data'] = {args.key: value}
    res = invoke(args.payload)
    print(json.dumps(res, sort_keys=True, indent=2, separators=(',', ': ')))
    exit(0)

def add_json_parser(parent, subparsers):
    p_json = subparsers.add_parser(parent, help=parent +' commands')
    sp_json = p_json.add_subparsers(help=parent + ' commands')

    parser_json_get = sp_json.add_parser('get', help='get ' + parent)
    parser_json_get.set_defaults(func=json_get, payload={'action': parent + '-get'})

    parser_json_set = sp_json.add_parser('set', help='set ' + parent)
    parser_json_set.set_defaults(func=json_set, payload={'action': parent + '-set'})
    parser_json_set.add_argument('key', help='key of the metadata')
    group = parser_json_set.add_mutually_exclusive_group()
    group.add_argument('--integer', '-i', help='value is integer ', action='store_true')
    group.add_argument('--float', '-f', help='value is float', action='store_true')
    group.add_argument('--string', '-s', help='value is string', action='store_true')
    group.add_argument('--json', '-j', help='value is json', action='store_true')
    parser_json_set.add_argument('value', help='value to be set')
    return sp_json


UTIL = "/opt/local/lib/fifo-tools/fifo"
parser = argparse.ArgumentParser(description='FiFo zone tools.')

parser.add_argument("--json", "-j", action='store_true', default=False, help="Return results as json")
parser.add_argument('--version', '-V', action='version', version='%(prog)s {{VERSION}}')
parser.add_argument('--verbose', '-v', action='store_true', default=False, help="Prints debug information")
subparsers = parser.add_subparsers(help='sub commands')

p_snaps = subparsers.add_parser('snapshots', help='Snapshot related commands')
sp_snaps = p_snaps.add_subparsers(help='snapshot commands')
p_snaps_list = sp_snaps.add_parser('list', help='lists snapshots')
p_snaps_list.add_argument('--fmt', action=ListAction, default=['uuid', 'comment'])
p_snaps_list.add_argument('-H', action='store_false')
p_snaps_list.add_argument('-p', action='store_true')
p_snaps_list.set_defaults(func=show_list, fmt_def=snap_fmt, payload={'action': 'snapshot-list'})

p_snap_create = sp_snaps.add_parser('create', help='gets snapshots')
p_snap_create.add_argument('comment', help='Comment for the snapshot.')
p_snap_create.set_defaults(func=snapshot_create, payload={'action': 'snapshot-create'})

p_backups = subparsers.add_parser('backups', help='Backup related commands')
sp_backups = p_backups.add_subparsers(help='backup commands')
p_backups_list = sp_backups.add_parser('list', help='lists backup')
p_backups_list.add_argument('--fmt', action=ListAction, default=['uuid', 'comment'])
p_backups_list.add_argument('-H', action='store_false', help="omit header")
p_backups_list.add_argument('-p', action='store_true',  help="parsable output")
p_backups_list.set_defaults(func=show_list, fmt_def=backup_fmt, payload={'action': 'backupshot-list'})

p_backup_create = sp_backups.add_parser('create', help='gets backupshots')
p_backup_create.add_argument('--parent', '-p', help='parent for the snapshot')
p_backup_create.add_argument('--delete', '-d', action='store_true',
                             help='delete snapshot after upload, or parent if specified')
p_backup_create.add_argument('comment', help='Comment for the backupshot.')
p_backup_create.set_defaults(func=backup_create, payload={'action': 'backup-create'})

add_json_parser('metadata', subparsers)

p_cluster = add_json_parser('cluster', subparsers)
p_cluster_vms = p_cluster.add_parser('vms', help='lists vms in the cluster')
p_cluster_vms.set_defaults(func=show_cluster_vms, payload={'action': 'cluster-vms'})

p_stack = add_json_parser('stack', subparsers)
p_stack_vms = p_stack.add_parser('vms', help='lists vms in the stack')
p_stack_vms.set_defaults(func=show_stack_vms, payload={'action': 'stack-vms'})


p_zfs = subparsers.add_parser('zfs', help='zfs related commands')
sp_zfs = p_zfs.add_subparsers(help='zfs commands')
p_zfs_list = sp_zfs.add_parser('list', help='lists zfs zones')
p_zfs_list.set_defaults(func=zfs_list)

args = parser.parse_args(sys.argv[1:])

debug = args.verbose

args.func(args)
